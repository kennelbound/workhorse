{
  "name": "grunt-hug",
  "description": "Concatinate your web application without worrying about the order of your files.",
  "version": "0.5.2",
  "homepage": "https://github.com/ozanturgut/grunt-hug",
  "author": {
    "name": "Ozan Turgut",
    "url": "http://oztu.org/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/ozanturgut/grunt-hug.git"
  },
  "bugs": {
    "url": "https://github.com/ozanturgut/grunt-hug/issues"
  },
  "licenses": [
    {
      "type": "Apache License 2.0",
      "url": "https://github.com/ozanturgut/grunt-hug/blob/master/LICENSE-APACHE2"
    }
  ],
  "main": "grunt.js",
  "scripts": {
    "test": "grunt test"
  },
  "dependencies": {},
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-clean": "~0.4.0rc6",
    "grunt-contrib-nodeunit": "~0.1.1",
    "grunt-contrib-jshint": "~0.1.0",
    "mocks": "~0.0.10",
    "sinon": "~1.5.2"
  },
  "keywords": [
    "gruntplugin"
  ],
  "readme": "# grunt-hug [![Build Status](https://secure.travis-ci.org/ozanturgut/grunt-hug.png?branch=master)](http://travis-ci.org/ozanturgut/grunt-hug)\n\nHug makes maintaining and packaging web applications easier, it is a [grunt](http://gruntjs.com) plugin. \nTell it how to find your files and it will concatinate them in the right order of dependencies. \nIt will also prevent accidental variable leakage between files by wrapping each file in a self-executing \nanonymous function.\n\n## Why Hugging Will Make You Happy\n\n* **Node-like `require` statements.** This tells grunt how your files are related so it can package your files in the\nright order. These statements won't be in the final packaged file.\n* **Automated dependency resolution.** It will figure out the required order for your files when concatinating.\n* **Path searching for dependencies.** Works great with[Bower](http://twitter.github.com/bower/) or \n[NPM](https://npmjs.org/), just add them to the search path.\n* **File-level variables** declarations won't leak to the environment and will remain at file-level.\n* Allows you to **define an API** for the package which can be used by other applications.\n\n## Target Audience\n\nHugging occurs at build-time, so an application which needs to load it's dependencies at runtime (lazy loading) \nwon't benefit much from hugging -- you'll likely prefer [RequireJS](http://requirejs.org/). \n\nFor frameworks or compiled applications, hugging is awesome. Your code will be clean, safe, and boiler-plate-free. \nAs an added benefit, your unhugged code will work in nodejs applications so long as you're not using any \nbrowser-specific functions (for example, `alert`).\n\n## How to Hug\n\n* Define the variables that a file will expose by assigning them to the `exports` variable. An example:\n`exports.numbers = [1,2,3];`.\n* Retrieve the exports of another file by using the `require` function. An example:  \n`var fileExports = require(\"[A RELATIVE PATH]\")`. \n\nIf you want to assign something as the exports object itself, assign it to `module.exports`. Assigning anything\ndirectly to `exports` would replace the object pointer entirely. If you've done nodejs programming \nbefore, you should already be used to this, just remember you can't import npm packages like \nyou can in node -- currently, hug only imports from relative file paths.\n\n## A Simple Example\nSay I have two files:\n```javascript\n// required.js \nexports.message = \"Hello, world!\";\n```\n\n```javascript\n// requiree.js\nvar otherFile = require('required.js');\nalert(otherFile.message);\n```\n\n```javascript\n// grunt.js\nmodule.exports = function(grunt){\n grunt.initConfig({\n \thug: {\n \t\tsimple: {\n \t\t\tsrc: \"./example/simple/**/*\",\n \t\t\tdest: \"./tmp/simple-example.js\"\n \t\t}\n \t}\n });\n}\n```\n\nWhen we run `grunt hug`, simple-example.js is generated. When simple-example.js runs in a browser, \nit will alert \"Hello, world!\". Note that the window object is never touched, the entire application \nis within a closure, it leaves no trace after it's run. Here is the file itself:\n\n```javascript\n// simple-example.js\n(function(){\n\tvar __m0=(function(module,exports){module.exports=exports;\n\t\texports.message = \"Hello, world!\";\n\t\t;return module.exports;\n\t}({},{}));\n\n\tvar __m1=(function(module,exports){module.exports=exports;\n\t\tvar otherFile = __m0;\n\n\t\talert(otherFile.message);\n\t\t;return module.exports;\n\t}({},{}));\n}());\n```\n\n## A More Complex Example\n\nSay I have the following file structure:\n```javascript\nsrc/\n    language/\n        message/\n                aSaying.js\n        composer.js\n        words.js\n    exports.js\n    speak.js\ngrunt.js\n```\n\nWith the following file contents:\n\n```javascript\n// src/language/message/aSaying.js\nvar theWord = require('../words.js').aWord;\nvar composer = require('../composer.js');\n\nexports.whatTheySay = composer(theWord);\n```\n\n```javascript\n// src/language/composer.js\nexports = function(anything){\n\treturn \"Hello, \" + anything + \"!\";\n};\n```\n\n```javascript\n// src/language/words.js\nexports.aWord = \"world\";\n```\n\n```javascript\n// src/exports.js\nexports.speak = require('./speak.js');\nexports.message = require('./language/message/aSaying.js').whatTheySay;\n```\n\n```javascript\n// src/speak.js\nvar theMessage = require('./language/message/aSaying.js').whatTheySay;\nmodule.exports = function(){\n\talert(theMessage);\n};\n```\n\n```javascript\n// grunt.js\n// ...other config stuff...\n// in the object passed into initConfig:\nhug: {\n\tadvanced: {\n      \t\tsrc: \"./src/**/*\",\n        \tdest: \"./tmp/advanced-example.js\",\n        \texportedVariable: \"myApi\",\n        \texports: \"./src/exports.js\"\n\t},\n}\n// ...other config stuff...\n```\n\nWhen grunt is asked to hugs these files, it'll concatinate the files in order of dependencies, \nwrap each file in an anonymous function, and match up dependencies.\n\nRunning `advanced-example.js` will create an object named `myApi` in the `window` object with the two variables\ndefined in exports.js as it's members. Running `myApi.speak()` will alert \"Hello, world\" in a browser.\n\n## Usage\n\n**If you've never used grunt before, you will find it very useful to review the \n[Getting Started](https://github.com/gruntjs/grunt/blob/0.3-stable/docs/getting_started.md) documentation.**\n\nInside your `grunt.js` file, in the object you pass to initConfig, add an object named `hug`. \nInside this object, add one or more objects for different `hug` tasks.\n\n#### Parameters\n\n##### src `String or Array`\n\nOne or more comma separated wildcard patterns as well as an array of wildcard patterns. These files define the source\ncode of your package. Which will be concatinated together.\n\n##### dest `String`\n\nThe path for the generated file. Grunt will automatically generate directories if they don't exit.\n\n##### (optional) path `String or Array`\n\nGrunt will use the given paths as a base (in addition to the current directory) when resolving dependencies.\n\nFor example if you set `path` to `[\"./components\"]`, and grunt runs in to a file with `require('jquery/jquery.js')`\nGrunt will search for the file both in the location relative to where it was declared, and in \n`./components/jquery/jquery.js`. \nThis works nicely with package managers such as [Bower](http://twitter.github.com/bower/) or [NPM](https://npmjs.org/).\n\n##### (optional) extensions `String or Array`\n\nGrunt will use this list of extensions when trying to resolve dependencies for files it can't find. By default\nthe extensions array is ['', '.js'], meaning, grunt will first try to find an exact match and then try to find\nthe same filename with the '.js' extension. So in the previous example for `path` we could have just used\n`require('jquery/jquery')` and it would have worked just as well.\n\n##### (optional) header `String or Array`\n\nFile(s) which will be prepended to the beginning of the package, making any variable defined in them package-global.\nNote that these files do not use the exports/require pattern -- what they would normally define as global become\nlimited to the scope of the package, so any file can use their variables without requiring them in.\n\nThis is particularly useful for utility functions that you do not want to keep requiring, or for libraries which\nrequire other libraries in order to work.\n\n##### (optional) exports `String`\n\nA path to a file to use as the exports object for the package. Whatever the file exports, will be exported by the entire\npackage. In essence, this file should define the external api of your package.\n\n##### (optional) exportedVariable `String` (defaults to \"exports\")\n\nIf exports is defined, this will be the variable exported to the environment. Whatever the `exports` file exports \nwill be assigned to this variable. By setting the value of this to \"module.exports\" you can create a package that\ncan be imported by other hug or nodejs applications.\n\n##### (optional & advanced) moduleVariableName `String` (defaults to \"module\")\n\nSetting this parameter will break compatibility with importable nodejs modules.\nThis parameter allows you to overwrite the variable name used to refer to modules internally. This is useful if\nyou already use the `module` variable for something else.\n\n##### (optional & advanced) exportsVariableName `String` (defaults to \"exports\")\n\nSetting this parameter will break compatibility with importable nodejs modules.\nThis parameter allows you to overwrite the variable name used to refer to exports internally. This is useful if\nyou already use the `exports` variable for something else.\n\n##### (optional & advanced) requireFunctionName `String` (defaults to \"require\")\n\nSetting this parameter will break compatibility with importable nodejs modules.\nThis parameter allows you to overwrite the variable name used to refer to the require function. \nThis is useful if you already use the `require` variable for something else.\n\n## Importing libraries\nWeb frameworks and applications that can normally be imported into nodejs applications work as intended.\nFor example, you can just `require` the underscore library file and use it as you would normally.\n\nLibraries which aren't node-friendly can be made importable without modifying the original file by adding an\n'adapter' file. Here's an example on how to make jQuery importable:\n\n```javascript\n// jquery-module.js\nrequire('./jquery.js');\nmodule.exports = window.jQuery;\njQuery.noConflict();\n```\n\nFirst we require the actual library so that it gets included in our package and so that it's evaluated before\nthis file. Then we export out the reference to jQuery. Finally, we call jQuery.noConflict() which returns the\njQuery window variable to it's previous owner (but our exports still points to the one we want).\n\nNow we can import jquery in other files like so: `var $ = require('./jquery-module.js');`.\n\n### Soy Templates\nClosure (Soy) templates work beautifully with grunt-hug. Just set your file's namespace to \"module.exports\" and you're done! \nYou can now`require` the generated soy file and it will provide an object with the templates in it.\n",
  "_id": "grunt-hug@0.5.2",
  "dist": {
    "shasum": "e4a0ccb88b64733a252051e7993c11a70a0f43c2",
    "tarball": "http://registry.npmjs.org/grunt-hug/-/grunt-hug-0.5.2.tgz"
  },
  "_npmVersion": "1.1.59",
  "_npmUser": {
    "name": "ozanturgut",
    "email": "ozanturgut@gmail.com"
  },
  "maintainers": [
    {
      "name": "ozanturgut",
      "email": "ozanturgut@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "e4a0ccb88b64733a252051e7993c11a70a0f43c2",
  "_resolved": "https://registry.npmjs.org/grunt-hug/-/grunt-hug-0.5.2.tgz",
  "_from": "grunt-hug@*"
}
